<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[YGP Blog]]></title>
        <description><![CDATA[When your website appears in search results in say Google, the text here will be shown underneath your website's title.]]></description>
        <link>http://website.com</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Sat, 12 Apr 2014 02:47:30 GMT</lastBuildDate>
        <atom:link href="http://website.com/feed.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Young Gyu Park]]></author>
        <pubDate>Sat, 12 Apr 2014 02:47:07 GMT</pubDate>
        <item>
            <title><![CDATA[nodejs fs module 소개]]></title>
            <description><![CDATA[<p>Today I felt very annoying to make a directory every day to create a new post. Because how my docpad blog system configured is to save each post into the folder named according to date information. For example today is 2014-04-05 then the directory structure will be like 2014/04/05/created_file. Hence I need to create day folder everyday since day will be chanaged everyday. If month changed then I also need to create month folder.
Therefore I want to automate the whole process to make the procedure simple.
The first thing I have done is to choose a proper task program
What I try to do is to make a recursive directory according to today date.</p>
<pre class="highlight"><code class="hljs javascript">dirs.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(dir)</span> {</span>
  dir_path += <span class="hljs-string">"/"</span> + dir
  console.log(<span class="hljs-string">"loop =&gt; "</span> + dir_path);
  fs.mkdir(dir_path, <span class="hljs-number">0755</span>, <span class="hljs-literal">true</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
    <span class="hljs-keyword">if</span> (err) {
      console.log(err);
    } <span class="hljs-keyword">else</span> {
      console.log(<span class="hljs-string">'Directory '</span> + directory + <span class="hljs-string">' created.'</span>);
    }
  });
});</code></pre>
]]></description>
            <link>http://website.com/posts/2014/04/06/nodejs_fs_module</link>
            <guid isPermaLink="true">http://website.com/posts/2014/04/06/nodejs_fs_module</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Sun, 06 Apr 2014 01:51:39 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[haskell 번역 시작]]></title>
            <description><![CDATA[<p><a href="https://github.com/pvorb/learn-you-a-haskell">https://github.com/pvorb/learn-you-a-haskell</a></p>
<p>&quot;learn you a haskell&quot;번역을 시작했다. 언제 마칠 수 알수는 없지만 한번 해 보는 거지 뭐......</p>
<p>일단 위의 주소가 원본 주소가 위에 저장소를 포크해서 한글 번역을 하기 위한 저장소를 만들었다.</p>
<p>가보자 아자 아자</p>
<p><img src="http://farm8.staticflickr.com/7455/12830798605_aa8746f66f.jpg" alt="text"></p>
]]></description>
            <link>http://website.com/posts/2014/03/16/diary</link>
            <guid isPermaLink="true">http://website.com/posts/2014/03/16/diary</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Sun, 16 Mar 2014 12:34:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[불교의 가르침과 깨달음]]></title>
            <description><![CDATA[<p>#</p>
<p>미국 일간지 허핑턴포스트가 보도한 &#39;멘탈&#39; 강한 사람들의 9가지 특징을 참고하라.</p>
<ol>
<li><p>사물을 객관적으로 본다</p>
<p>셰익스피어의 유명한 대사 중 &quot;세상에 좋고 나쁜 것은 다 생각하기 나름이다&quot;라는 대사가 있다. 상황을 어떻게 인식하느냐에 따라 득이 될 수도 있고 실이 될 수도 있다. 그러니 시련을 극복하기 위해서는 객관적으로 사물을 보라.</p>
</li>
<li><p>내려놓을 줄 안다</p>
<p>&quot;언제나 원하는 것을 다 가져야 한다&quot;는 생각은 버려라. 정신력이 강한 사람들은 삶이 계획대로 풀리지 않을 수 있다는 것 그리고 언제든 예상치 못한 일이 닥칠 수 있다는 것을 안다. 그들은 일이 잘 풀리지 않았을 때 운명을 탓 하면서 시간을 낭비하지 않는다.</p>
</li>
<li><p>냉정하고 침착하다</p>
<p>&#39;멘탈&#39;이 강하다는 것이 언제나 행복하다는 것을 의미하지 않는다. &quot;언제나 냉정하고 침착한 상태를 유지하는 것&quot;을 의미한다고 할리데이는 말한다. 정서적 안정과 냉정함을 유지할 수 있는 능력은 힘든 상황을 극복하는 데 있어 큰 자산이다.</p>
</li>
<li><p>행복에 집착하지 않는다</p>
<p>언제나 행복해야 한다고 믿는 것은 결국 불행으로 이어질 수 있다. 정신력이 강한 사람들은 부정적인 감정을 애써 회피하려 하지 않는다. 긍정적, 부정적인 상반된 감정들이 자연스럽게 공존할 수 있도록 내버려 두는 것이 강한 &#39;멘탈&#39;을 갖는 비결이다.</p>
</li>
<li><p>현실적 낙천주의자들이다</p>
<p>&#39;멘탈&#39;이 강한 사람들은 넘어지면 습관적으로 다시 일어난다. 짜증내고 희망이 없다며 불평하며 포기하지 않는다. 정신력이 강한 사람들은 낙천주의자의 &quot;희망&quot;과 비관주의자의 &quot;현실성&quot;을 견지하며 &quot;현실적인 낙천주의자&quot;인 경우가 많다.</p>
</li>
<li><p>과거가 아닌 현재에 산다</p>
<p>현재에 사는 것은 모든 것을 있는 그대로 인지하게 도와준다. 과거에 집착하고 미래만 바라보지 마라. 현재에 사는 것이 뇌 활동을 증진시키고, 정서를 안정시키며, 스트레스를 줄여준다고 과학적으로 증명된 바 있다.</p>
</li>
<li><p>꾸준히 목표를 향해 정진한다</p>
<p>정신력이 강한 사람들은 인내심이 있다. 한 정신학자는 성공에 관한 그녀의 연구에서 투지와 기개의 중요성을 역설하며 &quot;투지를 가지는 것은 장기적 목표를 이뤄낼 수 있는 열정이 있다는 것을 의미한다&quot;고 지적했다.</p>
</li>
<li><p>놓아줄 때를 안다</p>
<p>&#39;멘탈&#39;이 강한 사람들은 놓아줄 때를 안다. 행동은 컨트롤할 수 있지만 행동의 결과까지 컨트롤할 수 있는 건 아니다. 우리의 능력 밖에 있는 것은 쿨하게 놓아줘라. 컨트롤할 수 있는 것과 없는 것의 차이를 인지하고 포기해야 할 땐 포기하라.</p>
</li>
<li><p>그들의 삶을 사랑 한다</p>
<p>강한 정신력으로 무장하기 위한 마지막 열쇠는 삶의 시련 그 자체를 사랑하라는 거다. 우여곡절 그 자체가 우리의 삶이다. 받아들이기 싫은 일일지라도 그것들을 포용하는 데서 기쁨을 찾아라. 미국 작가 제인 로터의 말을 기억하라. &quot;네가 걸어가는 길의 장애물은 장애물이 아니다, 그게 네 길이다&quot;</p>
</li>
</ol>
]]></description>
            <link>http://website.com/posts/2014/03/09/diary</link>
            <guid isPermaLink="true">http://website.com/posts/2014/03/09/diary</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Sun, 09 Mar 2014 07:45:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[아인이 교육 일지 그리고 명상]]></title>
            <description><![CDATA[<h2 id="-">아인이 교육 일기</h2>
<p>아인이와 같이 청소를 했다. 아니 아인이에게 강압적인 자세로 이것 저것을 시켰다. 아인이는 이내 싫증을 느끼고는 다시 컴퓨터로 돌아와 만화를 보았다. 난 그때 내가 강압적인 자세인지도 몰랐다. 단지 내 말을 듣지 않는 아인이에게 점점 목소리를 높여만 갔다. 그 순간 나는 관리자였고 아인이는 단지 내말을 들어야 하는 말단 직원이었다. 그리고 그 순간 나는 무었이 잘못 되었는지도 몰랐다. 내가 무엇이 잘못 되었는지 깨닫게 된건 아인엄마가 와서 아인이와 함께 정리를 하는 것을 보고 난 후 였다. 아인 엄마는 아주 다정하게 하나 하나 설명해 주면서 같이 정리를 해 나갔다. 아인이는 그 정리 과정을 마치 하나의 또 다른 재미있는 놀이 쯤으로 생각하는 것 같았다. 아인이는 똑같은 방식으로 나에게도 신호를 주었다. 아인이는 정리할 물건에 대해서 어떻게 어디에 두어야 하는지 일일이 물었고, 나는 내가 어떻게 정리해야 되는지 몰랐고 매번 물어보는 아인이에게 짜증이 났다. 그래서 계속 치우라고만 소리를 쳤다. 이런 과정이 몇번 반복되고 나서 아인이는 금새 싫증을 느겼고 다시 TV를 보러 가 버렸다. 즉 아인이는 치우고 정리하는 놀이를 나와 할려구 했는데 아빠는 놀이에 참여하지 못하고 그냥 소리만 치고 있으니 당연히 같이 놀 수가 없는 것이다. 아인이와 나와의 가장 큰 차이점은 난 치우는것이 일이었고 아인이에게는 치우는 것이 놀이였다. 난 그 순간 나쁜 아빠였고, 전혀 교육적이지 않은 아빠였다. 일을 놀이라고 생각하는 아인이</p>
<h2 id="-">호흡 바라보기</h2>
<p>오전부터 마음이 무척 붕 떠있는 느낌이었다. 무슨 일을 해도 집중이 되지 않고 쉬이 피로해졌다. 그래서 정오쯤에 호흡 바라보기 명상을 한 이십분 정도 한것 같다. 여전히 명상중에도 갖은 망상으로 호흡을 놓치기 일수였다. 하지만 다시 돌아오고 놓치면 다시 돌아오기를 몇번 반복하고 나서 마음이 어느정도 차분해 짐을 느꼇다. 마음이 차분해지니 몸에 긴장감이 사라지고 몸에서 긴장감이 사라지자 나른함이 몰려왔다. 그리고는 달콤한 잠에 빠져들었다.</p>
]]></description>
            <link>http://website.com/posts/2014/03/08/diary</link>
            <guid isPermaLink="true">http://website.com/posts/2014/03/08/diary</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Sat, 08 Mar 2014 08:58:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Numpy Data Type]]></title>
            <description><![CDATA[<h1 id="-">배열 생성</h1>
<h2 id="introduction">Introduction</h2>
<p>5가지의 배열을 생성하기 위한 메커니즘</p>
<ul>
<li>다른 파이썬 데이터 구조( 리스트, 튜플)에서 변환</li>
<li>numpy 고유의 배열 생성 오브젝트( arrange, ones, zeros, etc )</li>
<li>표준 또는 맞춤형 포멧 또는 디스크에서 배열 읽기</li>
<li>스트링이나 버퍼를 통한 로우 바이트로 배열 생성</li>
<li>특별한 라이브러리 함수의 사용</li>
<li>This section will not cover means of replicating, joining, or otherwise expanding or mutating existing arrays.
Nor will it cover creating object arrays or record arrays.
Both of those are covered in their own sections.
*</li>
</ul>
<h2 id="converting-python-array_like-objects-to-numpy-arrays">Converting Python array_like Objects to Numpy Arrays</h2>
<p>In general, numerical data arranged in an array-like structure in Python can be converted to arrays through the use of the array() function. The most obvious examples are lists and tuples. See the documentation for array() for details for its use. Some objects may support the array-protocol and allow conversion to arrays this way. A simple way to find out if the object can be converted to a numpy array using array() is simply to try it interactively and see if it works! (The Python Way).</p>
<p>일반적으로, 파이썬에서 배열같은 구조의 숫자 데이터 배열은 array() 함수를</p>
<pre class="highlight"><code class="hljs python">x = np.array([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])
x = np.array([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])
x = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2.0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],(<span class="hljs-number">1</span>+<span class="hljs-number">1j</span>,<span class="hljs-number">3.</span>)]) <span class="hljs-comment"># note mix of tuple and lists, and types</span>
x = np.array([[ <span class="hljs-number">1.</span>+<span class="hljs-number">0.j</span>, <span class="hljs-number">2.</span>+<span class="hljs-number">0.j</span>], [ <span class="hljs-number">0.</span>+<span class="hljs-number">0.j</span>, <span class="hljs-number">0.</span>+<span class="hljs-number">0.j</span>], [ <span class="hljs-number">1.</span>+<span class="hljs-number">1.j</span>, <span class="hljs-number">3.</span>+<span class="hljs-number">0.j</span>]])</code></pre>
]]></description>
            <link>http://website.com/posts/2014/02/18/numpy_data_type</link>
            <guid isPermaLink="true">http://website.com/posts/2014/02/18/numpy_data_type</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Mon, 17 Feb 2014 18:57:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[파이썬 함수형 언어 파트 1]]></title>
            <description><![CDATA[<p>가장 어려운 질문인 함수형 언어가 무엇인지로 시작하는게 좋을것 같습니다. 한가지 답변은 함수형 언어는 Lisp, Scheme, Haskell, ML, OCAML, Clean, Mercury 또는 Erlang 같은 언어로 프로그램을 짜는 것을 말합니다. 이것은 가장 확실한 답변이지만은 아주 분명하게 설명을 하지는 않은 것입니다. 불행히도, 함수형 언어가 무엇인지에 관한 일관된 의견을 가지는 것은 참 어려운 일입니다. 심지어 함수형 프로그래머들도 정확한 정의를 하지 못하고 있습니다. 장님과 코끼리 이야기가 여기에서 참 적절한 예인것 같습니다. &quot;imperative languages&quot;
We&#39;d better start with the hardest question: &quot;What is functional programming (FP), anyway?&quot; One answer would be to say that FP is what you do when you program in languages like Lisp, Scheme, Haskell, ML, OCAML, Clean, Mercury, or Erlang (or a few others). That is a safe answer, but not one that clarifies very much. Unfortunately, it is hard to get a consistent opinion on just what FP is, even from functional programmers themselves. A story about elephants and blind men seems apropos here. It is also safe to contrast FP with &quot;imperative programming&quot; (what you do in languages like C, Pascal, C++, Java, Perl, Awk, TCL, and most others, at least for the most part).</p>
<p>개인적으로 저는 적어도 다음과 같은 특징들을 가진 언어를 함수형 언어로 간주합니다. 함수형 언어라 불리는 언어는 다음과 같은 것들을 쉽게 하거나 다른 것들을 어렵거나 불가능하게 합니다.
Personally, I would roughly characterize functional programming as having at least several of the following characteristics. Languages that get called functional make these things easy, and make other things either hard or impossible:</p>
<p>함수는 첫번째 클래스 또는 객체입니다. 즉 데이터를 가지고 할 수 있는 모든 것들을 함수로서도 할 수 있습니다. (예를 들면, 함수를 다른 함수의 인자로 넘기는 것과 같은 것들을 할 수 있어야 합니다.)
Functions are first class (objects). That is, everything you can do with &quot;data&quot; can be done with functions themselves (such as passing a function to another function).</p>
<p>재귀는 주요 제어 구조 방식으로 사용됩니다. 어떤 언어에서는 &quot;loop&quot; 반복문이 없습니다. 단지 LISt Process(LISP라는 이름은 이곳에서 왔습니다)에 초점을 맞추고 있습니다. 리스트는 종종 &quot;loop&quot;반복문을 대체하기 위한 방법으로서 하위 리스트에 관한 재귀 반복문을 사용합니다.
Recursion is used as a primary control structure. In some languages, no other &quot;loop&quot; construct exists.
There is a focus on LISt Processing (for example, the name Lisp). Lists are often used with recursion on sub-lists as a substitute for loops.</p>
<p>순수 함수형 언어는 부작용들을 회피합니다. 이것은 선언적 언어들 어디에서나 볼수 있는 한 변수에 값을 할당하고 또다른 값을 할당해서 프로그램의 상태를 추적하는 패턴을 배제합니다.
&quot;Pure&quot; functional languages eschew side-effects. This excludes the almost ubiquitous pattern in imperative languages of assigning first one, then another value to the same variable to track the program state.</p>
<p>함수형 언어는
FP either discourages or outright disallows statements, and instead works with the evaluation of expressions (in other words, functions plus arguments). In the pure case, one program is one expression (plus supporting definitions).</p>
<p>함수형 언어는 어떻게 계산 되어야 하는가보다는 무엇이 계산되어야 하는가에 초점을 맞춘다. 대부분의 함수형 언어는 &quot;고차원 순서&quot;함수 ( 다시 말해서 함수들에 기능하는 함수들에 또 다시 기능하는 함수들을 말한다. )를 이용한다.
FP worries about what is to be computed rather than how it is to be computed.
Much FP utilizes &quot;higher order&quot; functions (in other words, functions that operate on functions that operate on functions).
Advocates of functional programming argue that all these characteristic make for more rapidly developed, shorter, and less bug-prone code. Moreover, high theorists of computer science, logic, and math find it a lot easier to prove formal properties of functional languages and programs than of imperative languages and programs.
Inherent Python functional capabilities
Python has had most of the characteristics of FP listed above since Python 1.0. But as with most Python features, they have been present in a very mixed language. Much as with Python&#39;s OOP features, you can use what you want and ignore the rest (until you need it later). With Python 2.0, a very nice bit of &quot;syntactic sugar&quot; was added with list comprehensions. While list comprehensions add no new capability, they make a lot of the old capabilities look a lot nicer.
The basic elements of FP in Python are the functions map(), reduce(), and filter(), and the operator lambda. In Python 1.x, the apply() function also comes in handy for direct application of one function&#39;s list return value to another function. Python 2.0 provides an improved syntax for this purpose. Perhaps surprisingly, these very few functions (and the basic operators) are almost sufficient to write any Python program; specifically, the flow control statements (if, elif, else, assert, try, except, finally, for, break, continue, while, def) can all be handled in a functional style using exclusively the FP functions and operators. While actually eliminating all flow control commands in a program is probably only useful for entering an &quot;obfuscated Python&quot; contest (with code that will look a lot like Lisp), it is worth understanding how FP expresses flow control with functions and recursion.
Back to top
Eliminating flow control statements
The first thing to think about in our elimination exercise is the fact that Python &quot;short circuits&quot; evaluation of Boolean expressions. This provides an expression version of if/ elif/ else blocks (assuming each block calls one function, which is always possible to arrange). Here&#39;s how:
Listing 1. &quot;Short-circuit&quot; conditional calls in Python</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-comment"># Normal statement-based flow control</span>
<span class="hljs-keyword">if</span> &lt;cond1&gt;:   func1()
<span class="hljs-keyword">elif</span> &lt;cond2&gt;: func2()
<span class="hljs-keyword">else</span>:         func3()

<span class="hljs-comment"># Equivalent "short circuit" expression</span>
(&lt;cond1&gt; <span class="hljs-keyword">and</span> func1()) <span class="hljs-keyword">or</span> (&lt;cond2&gt; <span class="hljs-keyword">and</span> func2()) <span class="hljs-keyword">or</span> (func3())

<span class="hljs-comment"># Example "short circuit" expression</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>x = <span class="hljs-number">3</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pr</span><span class="hljs-params">(s)</span>:</span> <span class="hljs-keyword">return</span> s
<span class="hljs-prompt">&gt;&gt;&gt; </span>(x==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> pr(<span class="hljs-string">'one'</span>)) <span class="hljs-keyword">or</span> (x==<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> pr(<span class="hljs-string">'two'</span>)) <span class="hljs-keyword">or</span> (pr(<span class="hljs-string">'other'</span>))
<span class="hljs-string">'other'</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>x = <span class="hljs-number">2</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>(x==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> pr(<span class="hljs-string">'one'</span>)) <span class="hljs-keyword">or</span> (x==<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> pr(<span class="hljs-string">'two'</span>)) <span class="hljs-keyword">or</span> (pr(<span class="hljs-string">'other'</span>))
<span class="hljs-string">'two'</span></code></pre>
<p>Our expression version of conditional calls might seem to be nothing but a parlor trick; however, it is more interesting when we notice that the lambda operator must return an expression. Since -- as we have shown -- expressions can contain conditional blocks via short-circuiting, a lambda expression is fully general in expressing conditional return values. Building on our example:
Listing 2. Lambda with short-circuiting in Python</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>pr = <span class="hljs-keyword">lambda</span> s:s
<span class="hljs-prompt">&gt;&gt;&gt; </span>namenum = <span class="hljs-keyword">lambda</span> x: (x==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> pr(<span class="hljs-string">"one"</span>)) \
....                  <span class="hljs-keyword">or</span> (x==<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> pr(<span class="hljs-string">"two"</span>)) \
....                  <span class="hljs-keyword">or</span> (pr(<span class="hljs-string">"other"</span>))
<span class="hljs-prompt">&gt;&gt;&gt; </span>namenum(<span class="hljs-number">1</span>)
<span class="hljs-string">'one'</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>namenum(<span class="hljs-number">2</span>)
<span class="hljs-string">'two'</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>namenum(<span class="hljs-number">3</span>)
<span class="hljs-string">'other'</span></code></pre>
<h1 id="functions-as-first-class-objects">Functions as first class objects</h1>
<p>The above examples have already shown the first class status of functions in Python, but in a subtle way. When we create a function object with the lambda operation, we have something entirely general. As such, we were able to bind our objects to the names &quot;pr&quot; and &quot;namenum&quot;, in exactly the same way we might have bound the number 23 or the string &quot;spam&quot; to those names. But just as we can use the number 23 without binding it to any name (in other words, as a function argument), we can use the function object we created with lambda without binding it to any name. A function is simply another value we might do something with in Python.
The main thing we do with our first class objects, is pass them to our FP built-in functions map(), reduce(), and filter(). Each of these functions accepts a function object as its first argument.
map() performs the passed function on each corresponding item in the specified list(s), and returns a list of results.
reduce() performs the passed function on each subsequent item and an internal accumulator of a final result; for example, reduce(lambda n,m:n*m, range(1,10)) means &quot;factorial of 10&quot; (in other words, multiply each item by the product of previous multiplications).
filter() uses the passed function to &quot;evaluate&quot; each item in a list, and return a winnowed list of the items that pass the function test.
We also often pass function objects to our own custom functions, but usually those amount to combinations of the mentioned built-ins.
By combining these three FP built-in functions, a surprising range of &quot;flow&quot; operations can be performed (all without statements, only expressions).
Back to top</p>
<h1 id="functional-looping-in-python">Functional looping in Python</h1>
<p>Replacing loops is as simple as was replacing conditional blocks. for can be directly translated to map(). As with our conditional execution, we will need to simplify statement blocks to single function calls (we are getting close to being able to do this generally):
Listing 3. Replacing loops</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> lst:  func(e)      <span class="hljs-comment"># statement-based loop</span>
map(func,lst)           <span class="hljs-comment"># map()-based loop</span></code></pre>
<p>By the way, a similar technique is available for a functional approach to sequential program flow. That is, imperative programming mostly consists of statements that amount to &quot;do this, then do that, then do the other thing.&quot; map() lets us do just this:
Listing 4. Map-based action sequence</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-comment"># let's create an execution utility function</span>
do_it = <span class="hljs-keyword">lambda</span> f: f()

<span class="hljs-comment"># let f1, f2, f3 (etc) be functions that perform actions</span>

map(do_it, [f1,f2,f3])   <span class="hljs-comment"># map()-based action sequence</span></code></pre>
<p>In general, the whole of our main program can be a map() expression with a list of functions to execute to complete the program. Another handy feature of first class functions is that you can put them in a list.
Translating while is slightly more complicated, but is still possible to do directly:
Listing 5. Functional &#39;while&#39; looping in Python</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-comment"># statement-based while loop</span>
<span class="hljs-keyword">while</span> &lt;cond&gt;:
    &lt;pre-suite&gt;
    <span class="hljs-keyword">if</span> &lt;break_condition&gt;:
        breakelse:
        &lt;suite&gt;

<span class="hljs-comment"># FP-style recursive while loop</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">while_block</span><span class="hljs-params">()</span>:</span>
    &lt;pre-suite&gt;
    <span class="hljs-keyword">if</span> &lt;break_condition&gt;:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        &lt;suite&gt;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

while_FP = <span class="hljs-keyword">lambda</span>: (&lt;cond&gt; <span class="hljs-keyword">and</span> while_block()) <span class="hljs-keyword">or</span> while_FP()
while_FP()</code></pre>
<p>Our translation of while still requires a while_block() function that may itself contain statements rather than just expressions. But we might be able to apply further eliminations to that function (such as short circuiting the if/else in the template). Also, it is hard for <cond> to be useful with the usual tests, such as while myvar==7, since the loop body (by design) cannot change any variable values (well, globals could be modified in while_block()). One way to add a more useful condition is to let while_block() return a more interesting value, and compare that return for a termination condition. It is worth looking at a concrete example of eliminating statements:
Listing 6. Functional &#39;echo&#39; loop in Python</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-comment"># imperative version of "echo()"</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">echo_IMP</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:
        x = raw_input(<span class="hljs-string">"IMP -- "</span>)
        <span class="hljs-keyword">if</span> x == <span class="hljs-string">'quit'</span>:
            breakelseprint x
echo_IMP()

<span class="hljs-comment"># utility function for "identity with side-effect"</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">monadic_print</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">print</span> x
    <span class="hljs-keyword">return</span> x

<span class="hljs-comment"># FP version of "echo()"</span>
echo_FP = <span class="hljs-keyword">lambda</span>: monadic_print(raw_input(<span class="hljs-string">"FP -- "</span>))==<span class="hljs-string">'quit'</span> <span class="hljs-keyword">or</span> echo_FP()
echo_FP()</code></pre>
<p>What we have accomplished is that we have managed to express a little program that involves I/O, looping, and conditional statements as a pure expression with recursion (in fact, as a function object that can be passed elsewhere if desired). We do still utilize the utility function monadic_print(), but this function is completely general, and can be reused in every functional program expression we might create later (it&#39;s a one-time cost). Notice that any expression containing monadic_print(x)evaluates to the same thing as if it had simply contained x. FP (particularly Haskell) has the notion of a &quot;monad&quot; for a function that &quot;does nothing, and has a side-effect in the process.&quot;</p>
<p>Eliminating side-effects
After all this work in getting rid of perfectly sensible statements and substituting obscure nested expressions for them, a natural question is &quot;Why?!&quot; All of my descriptions of FP are achieved in Python. But the most important characteristic?and the one likely to be concretely useful?is the elimination of side-effects (or at least their containment to special areas like monads). A very large percentage of program errors?and the problem that drives programmers to debuggers?occur because variables obtain unexpected values during the course of program execution. Functional programs bypass this particular issue by simply not assigning values to variables at all.
Let&#39;s look at a fairly ordinary bit of imperative code. The goal here is to print out a list of pairs of numbers whose product is more than 25. The numbers that make up the pairs are themselves taken from two other lists. This sort of thing is moderately similar to things that programmers actually do in segments of their programs. An imperative approach to the goal might look like:
Listing 7. Imperative Python code for &quot;print big products&quot;</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-comment"># Nested loop procedural style for finding big products</span>
xs = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
ys = (<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-number">22</span>)
bigmuls = []
<span class="hljs-comment"># ...more stuff...</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xs:
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ys:
        <span class="hljs-comment"># ...more stuff...</span>
        <span class="hljs-keyword">if</span> x*y &gt; <span class="hljs-number">25</span>:
            bigmuls.append((x,y))
            <span class="hljs-comment"># ...more stuff...</span>
<span class="hljs-comment"># ...more stuff...</span>
<span class="hljs-keyword">print</span> bigmuls</code></pre>
<p>This project is small enough that nothing is likely to go wrong. But perhaps our goal is embedded in code that accomplishes a number of other goals at the same time. The sections commented with &quot;more stuff&quot; are the places where side-effects are likely to lead to bugs. At any of these points, the variables xs, ys, bigmuls, x, y might acquire unexpected values in the hypothetical abbreviated code. Furthermore, after this bit of code is done, all the variables have values that may or may not be expected and wanted by later code. Obviously, encapsulation in functions/instances and care regarding scope can be used to guard against this type of error. And you can always del your variables when you are done with them. But in practice, the types of errors indicated are common.
A functional approach to our goal eliminates these side-effect errors altogether. A possible bit of code is:
Listing 8. Functional approach to our goal
bigmuls = lambda xs,ys: filter(lambda (x,y):x<em>y &gt; 25, combine(xs,ys))
combine = lambda xs,ys: map(None, xs</em>len(ys), dupelms(ys,len(xs)))
dupelms = lambda lst,n: reduce(lambda s,t:s+t, map(lambda l,n=n: [l]*n, lst))
print bigmuls((1,2,3,4),(10,15,3,22))
We bind our anonymous (lambda) function objects to names in the example, but that is not strictly necessary. We could instead simply nest the definitions. For readability we do it this way; but also because combine() is a nice utility function to have anyway (produces a list of all pairs of elements from two input lists). dupelms() in turn is mostly just a way of helping out combine(). Even though this functional example is more verbose than the imperative example, once you consider the utility functions for reuse, the new code in bigmuls() itself is probably slightly less than in the imperative version.
The real advantage of this functional example is that absolutely no variables change any values within it. There are no possible unanticipated side-effects on later code (or from earlier code). Obviously, the lack of side-effects, in itself, does not guarantee that the code is correct, but it is nonetheless an advantage. Notice, however, that Python (unlike many functional languages) does not prevent rebinding of the names bigmuls, combine and dupelms. If combine() starts meaning something different later in the program, all bets are off. You could work up a Singleton class to contain this type of immutable bindings (as, say, s.bigmuls and so on); but this column does not have room for that.
One thing distinctly worth noticing is that our particular goal is tailor-made for a new feature of Python 2. Rather than either the imperative or functional examples given, the best (and functional) technique is:</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-keyword">print</span> [(x,y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> (<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-number">22</span>) <span class="hljs-keyword">if</span> x*y &gt; <span class="hljs-number">25</span>]</code></pre>
]]></description>
            <link>http://website.com/posts/2014/02/12/Functional_Programming_in_Python_part1</link>
            <guid isPermaLink="true">http://website.com/posts/2014/02/12/Functional_Programming_in_Python_part1</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Wed, 12 Feb 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[파이썬 함수형 언어 파트 2]]></title>
            <description><![CDATA[<p>파트 1에서 함수형 언어 개념의 기본을 설명했습니다. 이번장에서는 좀더 깊은 개념적 영역으로 들어가 보겠습니다. Bryn Keller씨의 &quot;Xoltar Toolkit&quot;이 아주 큰 도움이 될 것입니다. Keller씨 이 Toolkit은 함수형 언어의 많은 장점들을 순수한 파이썬 언어의 기능으로 구현해 놓았습니다. 이 모듈은 함수형 기능뿐만 아니라 필요할때 수행되는 lazy evaluation 기능도 또한 포함하고 있습니다. 많은 전통적 함수형 언어들은 lazy evaluation을 가지고 있으며, 이 모듈은 또한 해스켈과 같은 함수형 언어에서 찾을 수 있는 많은 것들을 할 수 있게 합니다.</p>
<p>In Part 1, my previous column on functional programming, I introduced some basic concepts of FP. This column will delve a little bit deeper into this quite rich conceptual realm. For much of our delving, Bryn Keller&#39;s &quot;Xoltar Toolkit&quot; will provide valuable assistance. Keller has collected many of the strengths of FP into a nice little module containing pure Python implementations of the techniques. In addition to the module functional, Xoltar Toolkit includes the lazy module, which supports structures that evaluate &quot;only when needed.&quot; Many traditionally functional languages also have lazy evaluation, so between these components, the Xoltar Toolkit lets you do much of what you might find in a functional language like Haskell.</p>
<h1 id="bindings">Bindings</h1>
<p>제가 파트 1에서 설명한 함수형 기술들이 어떤 한계점을 가지고 있다는 것을 기억할 것입니다. 특히, 파이썬에서는 함수명을 다시 바인딩하는 할 수 있습니다. 하지만 함수형 언어에서는 일반적으로 이름이라는 것은 좀더 긴 표현의 축약형 정도로 이해합니다. 하지만 &quot;같은 표현은 항상 같은 결과를 수행해야 한다&quot;는 묵시적인 약속입니다. 만약 명시적 의미의 이름이 다시 바인딩을 한다면, 그 약속은 깨어집니다. 예를들면, 다음과 같은 함수형 프로그램에서 사용할 간단한 표현을 정의해 보겠습니다.</p>
<p>Alert readers will remember a limitation that I pointed out in the functional techniques described in Part 1. Specifically, nothing in Python prevents the rebinding of names that are used to denote functional expressions. In FP, names are generally understood to be abbreviations of longer expressions, but the promise is implicit that &quot;the same expression will always evaluate to the same result.&quot; If denotational names get rebound, the promise is broken. For example, let&#39;s say that we define some shorthand expressions that we&#39;d like to use in our functional program, such as:</p>
<p>Listing 1. Python FP session with rebinding causing mischief</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>car = <span class="hljs-keyword">lambda</span> lst: lst[<span class="hljs-number">0</span>]
<span class="hljs-prompt">&gt;&gt;&gt; </span>cdr = <span class="hljs-keyword">lambda</span> lst: lst[<span class="hljs-number">1</span>:]
<span class="hljs-prompt">&gt;&gt;&gt; </span>sum2 = <span class="hljs-keyword">lambda</span> lst: car(lst)+car(cdr(lst))
<span class="hljs-prompt">&gt;&gt;&gt; </span>sum2(range(<span class="hljs-number">10</span>))
<span class="hljs-number">1</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>car = <span class="hljs-keyword">lambda</span> lst: lst[<span class="hljs-number">2</span>]
<span class="hljs-prompt">&gt;&gt;&gt; </span>sum2(range(<span class="hljs-number">10</span>))
<span class="hljs-number">5</span></code></pre>
<p>불행히도, mutable 변수를 인자로 사용하고 있지 않은 같은 표현 sum2(range(10))은 두 지점에서 서로다른 두 결과를 수행하고 있습니다.</p>
<p>Unfortunately, the very same expression sum2(range(10)) evaluates to two different things at two points in our program, even though this expression itself does not use any mutable variables in its arguments.</p>
<p>다행이도 함수형 모듈은 실수로 리바인딩 방지하기 위한 바인딩이라고 불리는 클래스를 제공합니다. (파이썬은 어떠한 것도
The module functional, fortunately, provides a class called Bindings (proposed to Keller by yours truly) that prevents such rebindings (at least accidentally, Python does not try to prevent a determined programmer who wants to break things). While use of Bindings requires a little extra syntax, it makes it difficult for accidents to happen. In his examples within the functional module, Keller names a Bindings instance let (I presume after the let keyword in ML-family languages). For example, we might do:</p>
<p>Listing 2. Python FP session with guarded rebinding</p>
<pre class="highlight"><code class="hljs undefined">&gt;&gt;&gt; from functional import *
&gt;&gt;&gt; let = Bindings()
&gt;&gt;&gt; let.car = lambda lst: lst[0]
&gt;&gt;&gt; let.car = lambda lst: lst[2]
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1, in ?
  File "d:\tools\functional.py", line 976, in __setattr__
    raise BindingError, "Binding '%s' cannot be modified." % name
functional.BindingError:  Binding 'car' cannot be modified.
&gt;&gt;&gt; car(range(10))
0</code></pre>
<p>Obviously, a real program would have to do something about catching these &quot;BindingError&quot;s, but the fact they are raised avoids a class of problems.
Along with Bindings, functional provides a namespace function to pull off a namespace (really, a dictionary) from a Bindings instance. This comes in handy if you want to compute an expression within a (immutable) namespace defined in a Bindings. The Python function eval() allows evaluation within a namespace. An example should clarify:</p>
<p>Listing 3. Python FP session using immutable namespaces</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>let = Bindings()      <span class="hljs-comment"># "Real world" function names</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>let.r10 = range(<span class="hljs-number">10</span>)
<span class="hljs-prompt">&gt;&gt;&gt; </span>let.car = <span class="hljs-keyword">lambda</span> lst: lst[<span class="hljs-number">0</span>]
<span class="hljs-prompt">&gt;&gt;&gt; </span>let.cdr = <span class="hljs-keyword">lambda</span> lst: lst[<span class="hljs-number">1</span>:]
<span class="hljs-prompt">&gt;&gt;&gt; </span>eval(<span class="hljs-string">'car(r10)+car(cdr(r10))'</span>, namespace(let))
<span class="hljs-prompt">&gt;&gt;&gt; </span>inv = Bindings()      <span class="hljs-comment"># "Inverted list" function names</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>inv.r10 = let.r10
<span class="hljs-prompt">&gt;&gt;&gt; </span>inv.car = <span class="hljs-keyword">lambda</span> lst: lst[-<span class="hljs-number">1</span>]
<span class="hljs-prompt">&gt;&gt;&gt; </span>inv.cdr = <span class="hljs-keyword">lambda</span> lst: lst[:-<span class="hljs-number">1</span>]
<span class="hljs-prompt">&gt;&gt;&gt; </span>eval(<span class="hljs-string">'car(r10)+car(cdr(r10))'</span>, namespace(inv))
<span class="hljs-number">17</span></code></pre>
<h1 id="closures">Closures</h1>
<p>함수형언어의 아주 흥미로운 개념 중 하나는 closure입니다. 실은, 클로져는 많은 개발자에게 충분히 흥미로운 것입니다. 심지어 비함수형 언어인 펄이나 루비같은 언어도 이 클로저를 피처로 포함하고 있습니다. 더욱이 파이썬 2.1은 클로저의 대부분의 기능을 포함한 문법을 추가하려고 하고 있습니다.</p>
<p>One very interesting concept in FP is a closure. In fact, closures are sufficiently interesting to many developers that even generally non-functional languages like Perl and Ruby include closures as a feature. Moreover, Python 2.1 currently appears destined to add lexical scoping, which will provide most of the capabilities of closures.</p>
<p>그럼 클로저가 무엇일까요? Steve Majewski가 최근에 파이썬 뉴스그룹에서 클로저에 관한 멋진 설명을 하였습니다. 즉 클로저란 OOP의 Hyde에 대한 함수형 언어의 Jekyll과 같은 어떤것입니다. 객체의 인스턴스와 같은 클로저는 데이터와 함수를 함께 감싼 어떤 묶음을 다루는 방식입니다. 한발 물러서서 객체와 클로저가 해결할 수 있는 문제를 살펴보죠 그리고
So what is a closure, anyway? Steve Majewski has recently provided a nice characterization of the concept on the Python newsgroup:
That is, a closure is something like FP&#39;s Jekyll to OOP&#39;s Hyde (or perhaps the roles are the other way around). A closure, like an object instance, is a way of carrying around a bundle of data and functionality, wrapped up together.
Let&#39;s step back just a bit to see what problem both objects and closures solve, and also to see how the problem can be solved without either. The result returned by a function is usually determined by the context used in its calculation. The most common -- and perhaps the most obvious -- way of specifying this context is to pass some arguments to the function that tell it what values it should operate on. But sometimes also, there is a natural distinction between &quot;background&quot; and &quot;foreground&quot; arguments -- between what the function is doing this particular time, and the way the function is &quot;configured&quot; for multiple potential calls.
There are a number of ways to handle background, while focussing on foreground. One way is to simply &quot;bite the bullet&quot; and, at every invocation, pass every argument a function needs. This often amounts to passing a number of values (or a structure with multiple slots) up and down a call chain, on the possibility the values will be needed somewhere in the chain. A trivial example might look like:</p>
<p>Listing 4. Python session showing cargo variable</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-params">(n)</span>:</span>
<span class="hljs-prompt">... </span>    add7 = b(n)
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">return</span> add7
...
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-params">(n)</span>:</span>
<span class="hljs-prompt">... </span>    i = <span class="hljs-number">7</span>
<span class="hljs-prompt">... </span>    j = c(i,n)
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">return</span> j
...
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-params">(i,n)</span>:</span>
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">return</span> i+n
...
<span class="hljs-prompt">&gt;&gt;&gt; </span>a(<span class="hljs-number">10</span>)     <span class="hljs-comment"># Pass cargo value for use downstream</span>
<span class="hljs-number">17</span></code></pre>
<p>In the cargo example, within b(), n has no purpose other than being available to pass on to c(). Another option is to use global variables:
Listing 5. Python session showing global variable</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>N = <span class="hljs-number">10</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addN</span><span class="hljs-params">(i)</span>:</span>
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">global</span> N
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">return</span> i+N
...
<span class="hljs-prompt">&gt;&gt;&gt; </span>addN(<span class="hljs-number">7</span>)   <span class="hljs-comment"># Add global N to argument</span>
<span class="hljs-number">17</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>N = <span class="hljs-number">20</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>addN(<span class="hljs-number">6</span>)   <span class="hljs-comment"># Add global N to argument</span>
<span class="hljs-number">26</span></code></pre>
<p>The global N is simply available whenever you want to call addN(), but there is no need to pass the global background &quot;context&quot; explicitly. A somewhat more Pythonic technique is to &quot;freeze&quot; a variable into a function using a default argument at definition time:
Listing 6. Python session showing frozen variable</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>N = <span class="hljs-number">10</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addN</span><span class="hljs-params">(i, n=N)</span>:</span>
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">return</span> i+n
...
<span class="hljs-prompt">&gt;&gt;&gt; </span>addN(<span class="hljs-number">5</span>)   <span class="hljs-comment"># Add 10</span>
<span class="hljs-number">15</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>N = <span class="hljs-number">20</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>addN(<span class="hljs-number">6</span>)   <span class="hljs-comment"># Add 10 (current N doesn't matter)</span>
<span class="hljs-number">16</span></code></pre>
<p>Our frozen variable is essentially a closure. Some data is &quot;attached&quot; to the addN() function. For a complete closure, all the data present when addN() was defined would be available at invocation. However, in this example (and many more robust ones), it is simple to make enough available with default arguments. Variables that are never used by addN() thereby make no difference to its calculation.
Let&#39;s look next at an OOP approach to a slightly more realistic problem. The time of year has prompted my thoughts about those &quot;interview&quot; style tax programs that collect various bits of data -- not necessarily in a particular order -- then eventually use them all for a calculation. Let&#39;s create a simplistic version of this:
Listing 7. Python-style tax calculation class/instance</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxCalc</span>:</span>
    deftaxdue(self):<span class="hljs-keyword">return</span> (self.income-self.deduct)*self.rate
taxclass = TaxCalc()
taxclass.income = <span class="hljs-number">50000</span>
taxclass.rate = <span class="hljs-number">0.30</span>
taxclass.deduct = <span class="hljs-number">10000</span>
<span class="hljs-keyword">print</span><span class="hljs-string">"Pythonic OOP taxes due ="</span>, taxclass.taxdue()</code></pre>
<p>In our TaxCalc class (or rather, in its instance), we can collect some data -- in whatever order we like -- and once we have all the elements needed, we can call a method of this object to perform a calculation on the bundle of data. Everything stays together within the instance, and further, a different instance can carry a different bundle of data. The possibility of creating multiple instances, differing only their data is something that was not possible in the &quot;global variable&quot; or &quot;frozen variable&quot; approaches. The &quot;cargo&quot; approach can handle this, but for the expanded example, we can see it might become necessary to start passing around numerous values. While we are here, it is interesting to note how a message-passing OOP style might approach this (Smalltalk or Self are similar to this, and so are several OOP xBase variants I have used):
Listing 8. Smalltalk-style (Python) tax calculation</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxCalc</span>:</span>
    deftaxdue(self):<span class="hljs-keyword">return</span> (self.income-self.deduct)*self.rate
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setIncome</span><span class="hljs-params">(self,income)</span>:</span>
        self.income = income
        <span class="hljs-keyword">return</span> self
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setDeduct</span><span class="hljs-params">(self,deduct)</span>:</span>
        self.deduct = deduct
        <span class="hljs-keyword">return</span> self
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setRate</span><span class="hljs-params">(self,rate)</span>:</span>
        self.rate = rate
        <span class="hljs-keyword">return</span> self
<span class="hljs-keyword">print</span><span class="hljs-string">"Smalltalk-style taxes due ="</span>, \
      TaxCalc().setIncome(<span class="hljs-number">50000</span>).setRate(<span class="hljs-number">0.30</span>).setDeduct(<span class="hljs-number">10000</span>).taxdue()</code></pre>
<p>Returning self with each &quot;setter&quot; allows us to treat the &quot;current&quot; thing as a result of every method application. This will have some interesting similarities to the FP closure approach.
With the Xoltar toolkit, we can create full closures that have our desired property of combining data with a function, and also allowing multiple closure (nee objects) to contain different bundles:</p>
<p>Listing 9. Python Functional-style tax calculations</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-keyword">from</span> functional <span class="hljs-keyword">import</span> *

taxdue        = <span class="hljs-keyword">lambda</span>: (income-deduct)*rate
incomeClosure = <span class="hljs-keyword">lambda</span> income,taxdue: closure(taxdue)
deductClosure = <span class="hljs-keyword">lambda</span> deduct,taxdue: closure(taxdue)
rateClosure   = <span class="hljs-keyword">lambda</span> rate,taxdue: closure(taxdue)

taxFP = taxdue
taxFP = incomeClosure(<span class="hljs-number">50000</span>,taxFP)
taxFP = rateClosure(<span class="hljs-number">0.30</span>,taxFP)
taxFP = deductClosure(<span class="hljs-number">10000</span>,taxFP)
<span class="hljs-keyword">print</span><span class="hljs-string">"Functional taxes due ="</span>,taxFP()

<span class="hljs-keyword">print</span><span class="hljs-string">"Lisp-style taxes due ="</span>, \
      incomeClosure(<span class="hljs-number">50000</span>,
          rateClosure(<span class="hljs-number">0.30</span>,
              deductClosure(<span class="hljs-number">10000</span>, taxdue)))()</code></pre>
<p>Each closure function we have defined takes any values defined within the function scope, and binds those values into the global scope of the function object. However, what appears as the function&#39;s global scope is not necessarily the same as the true module global scope, nor identical to a different closure&#39;s &quot;global&quot; scope. The closure simply &quot;carries the data&quot; with it.
In our example, we utilize a few particular functions to put specific bindings within a closure&#39;s scope (income, deduct, rate). It would be simple enough to modify the design to put any arbitrary binding into scope. We also -- just for the fun of it -- use two slightly different functional styles in the example. The first successively binds additional values into closure scope; by allowing taxFP to be mutable, these &quot;add to closure&quot; lines can appear in any order. However, if we were to use immutable names like tax_with_Income, we would have to arrange the binding lines in a specific order, and pass the earlier bindings to the next ones. In any case, once everything necessary is bound into closure scope, we can call the &quot;seeded&quot; function.
The second style looks a bit more like Lisp, to my eyes (the parentheses mostly). Beyond the aesthetic, two interesting things happen in the second style. The first is that name binding is avoided altogether. This second style is a single expression, with no statements used (see Part 1 for a discussion of why this matters).
The other interesting thing about the &quot;Lisp-style&quot; use of the closures is how much it resembles the &quot;Smalltalk-style&quot; message-passing methods given above. Both essentially accumulate values along the way to calling the taxdue() function/method (both will raise errors in these crude versions if the right data is not available). The &quot;Smalltalk-style&quot; passes an object between each step, while the &quot;Lisp-style&quot; passes a continuation. But deep down, functional and object-oriented programming amount to much the same thing.</p>
]]></description>
            <link>http://website.com/posts/2014/02/13/Functional_Programming_in_Python_part2</link>
            <guid isPermaLink="true">http://website.com/posts/2014/02/13/Functional_Programming_in_Python_part2</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Wed, 12 Feb 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[파이썬 함수형 언어 파트 3]]></title>
            <description><![CDATA[<h1 id="expression-bindings">Expression bindings</h1>
<p>결코 부분적 해결책들에 만족하지 마라 -
Never content with partial solutions, one reader -- Richard Davies -- raised the issue of whether we might move bindings all the way into individual expressions. Let&#39;s take a quick look at why we might want to do that, and also show a remarkably elegant means of expression provided by a comp.lang.python contributor.</p>
<p>먼저 functional module의 Bindings 클래스를 다시 생각해 보겠습니다. 그 클래스의 속성들을 사용하여,
Let&#39;s first recall the Bindings class of the functional module. Using the attributes of that class, we were able to assure that a particular name means only one thing within a given block scope:</p>
<p>Listing 1: Python FP session with guarded rebinding</p>
<pre class="highlight"><code class="hljs undefined">&gt;&gt;&gt; from functional import *
&gt;&gt;&gt; let = Bindings()
&gt;&gt;&gt; let.car = lambda lst: lst[0]
&gt;&gt;&gt; let.car = lambda lst: lst[2]
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1, in ?
  File "d:\tools\functional.py", line 976, in __setattr__

raise BindingError, "Binding '%s' cannot be modified." % name
functional.BindingError:  Binding 'car' cannot be modified.
&gt;&gt;&gt; let.car(range(10))
0</code></pre>
<p>The Bindings class does what we want within a module or function def scope, but there is no way to make it work within a single expression. In ML-family languages, however, it is natural to create bindings within a single expression:
Listing 2: Haskell expression-level name bindings</p>
<pre class="highlight"><code class="hljs haskell"><span class="hljs-comment">-- car (x:xs) = x  -- *could* create module-level binding</span>
<span class="hljs-title">list_of_list</span> = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]

<span class="hljs-comment">-- 'where' clause for expression-level binding</span>
<span class="hljs-title">firsts1</span> = [car x | x &lt;- list_of_list] <span class="hljs-keyword">where</span> car (x:xs) = x

<span class="hljs-comment">-- 'let' clause for expression-level binding</span>
<span class="hljs-title">firsts2</span> = <span class="hljs-keyword">let</span> car (x:xs) = x <span class="hljs-keyword">in</span> [car x | x &lt;- list_of_list]

<span class="hljs-comment">-- more idiomatic higher-order 'map' technique</span>
<span class="hljs-title">firsts3</span> = map car list_of_list <span class="hljs-keyword">where</span> car (x:xs) = x

<span class="hljs-comment">-- Result: firsts1 == firsts2 == firsts3 == [1,4,7]</span></code></pre>
<p>Greg Ewing observed that it is possible to accomplish the same effect using Python&#39;s list comprehensions; we can even do it in a way that is nearly as clean as Haskell&#39;s syntax:
Listing 3: Python 2.0+ expression-level name bindings</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>list_of_list = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]
<span class="hljs-prompt">&gt;&gt;&gt; </span>[car_x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list_of_list <span class="hljs-keyword">for</span> car_x <span class="hljs-keyword">in</span>
 (x[<span class="hljs-number">0</span>],)]
[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]
This trick of putting an expression inside a single-item tuple <span class="hljs-keyword">in</span> a list comprehension does <span class="hljs-keyword">not</span> provide any way of using expression-level bindings <span class="hljs-keyword">with</span> higher-order functions. To use the higher-order functions, we still need to use block-level bindings, <span class="hljs-keyword">as</span> <span class="hljs-keyword">with</span>:
Listing <span class="hljs-number">4</span>: Python block-level bindings <span class="hljs-keyword">with</span> <span class="hljs-string">'map()'</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>list_of_list = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]
<span class="hljs-prompt">&gt;&gt;&gt; </span>let = Bindings()
<span class="hljs-prompt">&gt;&gt;&gt; </span>let.car = <span class="hljs-keyword">lambda</span> l: l[<span class="hljs-number">0</span>]
<span class="hljs-prompt">&gt;&gt;&gt; </span>map(let.car,list_of_list)
[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]</code></pre>
<p>Not bad, but if we want to use map(), the scope of the binding remains a little broader than we might want. Nonetheless, it is possible to coax list comprehensions into doing our name bindings for us, even in cases where a list is not what we finally want:
Listing 5: &quot;Stepping down&quot; from Python list comprehension</p>
<pre class="highlight"><code class="hljs haskell"><span class="hljs-type">Compare</span> <span class="hljs-type">Haskell</span> expression:
<span class="hljs-title">result</span> = func car_car
         <span class="hljs-keyword">where</span>
             car (x:xs) = x
             car_car = car (car list_of_list)
             func x = x + x^<span class="hljs-number">2</span></code></pre>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>[func <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list_of_list
...
<span class="hljs-keyword">for</span> car <span class="hljs-keyword">in</span> (x[<span class="hljs-number">0</span>],)
...
<span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> (car+car**<span class="hljs-number">2</span>,)][<span class="hljs-number">0</span>]
<span class="hljs-number">2</span></code></pre>
<p>We have performed an arithmetic calculation on the first element of the first element of list_of_list while also naming the arithmetic calculation (but only in expression scope). As an &quot;optimization&quot; we might not bother to create a list longer than one element to start with, since we choose only the first element with the ending index 0:
Listing 6: Efficient stepping down from list comprehension</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span>[func <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list_of_list[:<span class="hljs-number">1</span>]
<span class="hljs-prompt">... </span>      <span class="hljs-keyword">for</span> car <span class="hljs-keyword">in</span> (x[<span class="hljs-number">0</span>],)
<span class="hljs-prompt">... </span>      <span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> (car+car**<span class="hljs-number">2</span>,)][<span class="hljs-number">0</span>]
<span class="hljs-number">2</span></code></pre>
<h1 id="higher-order-functions-currying">Higher-order functions: currying</h1>
<p>Three of the most general higher-order functions are built into Python: map(), reduce(), and filter(). What these functions do -- and the reason we call them &quot;higher-order&quot; -- is take other functions as (some of) their arguments. Other higher-order functions, but not these built-ins, return function objects.
Python has always given users the ability to construct their own higher-order functions by virtue of the first-class status of function objects. A trivial case might look like this:
Listing 7: Trivial Python function factory</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo_factory</span><span class="hljs-params">()</span>:</span>
...
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
...
<span class="hljs-keyword">print</span>
<span class="hljs-string">"Foo function from factory"</span>
...
<span class="hljs-keyword">return</span> foo
...
<span class="hljs-prompt">&gt;&gt;&gt; </span>f = foo_factory()
<span class="hljs-prompt">&gt;&gt;&gt; </span>f()</code></pre>
<h1 id="foo-function-from-factory">Foo function from factory</h1>
<p>The Xoltar Toolkit, which I discussed in Part 2 of this series, comes with a nice collection of higher-order functions. Most of the functions that Xoltar&#39;s functional module provides are ones developed in various traditionally functional languages, and whose usefulness have been proven over many years.
Possibly the most famous and most important higher-order function is curry(). curry() is named after the logician Haskell Curry, whose first name is also used to name the above-mentioned programming language. The underlying insight of &quot;currying&quot; is that it is possible to treat (almost) every function as a partial function of just one argument. All that is necessary for currying to work is to allow the return value of functions to themselves be functions, but with the returned functions &quot;narrowed&quot; or &quot;closer to completion.&quot; This works quite similarly to the closures I wrote about in Part 2 -- each successive call to a curried return function &quot;fills in&quot; more of the data involved in a final computation (data attached to a procedure).
Let&#39;s illustrate currying first with a very simple example in Haskell, then with the same example repeated in Python using the functional module:
Listing 8: Currying a Haskell computation
computation a b c d = (a + b^2+ c^3 + d^4)
check = 1 + 2^2 + 3^3 + 5^4</p>
<p>fillOne   = computation 1
-- specify &quot;a&quot;
fillTwo   = fillOne 2
-- specify &quot;b&quot;
fillThree = fillTwo 3
-- specify &quot;c&quot;
answer    = fillThree 5
-- specify &quot;d&quot;
-- Result: check == answer == 657</p>
<p>Now in Python:
Listing 9: Currying a Python computation</p>
<blockquote>
<blockquote>
<blockquote>
<p>from functional import curry
computation = lambda a,b,c,d: (a + b<strong>2 + c</strong>3 + d**4)
computation(1,2,3,5)
657
fillZero  = curry(computation)
fillOne   = fillZero(1)</p>
<h1 id="specify-a-">specify &quot;a&quot;</h1>
<p>fillTwo   = fillOne(2)</p>
<h1 id="specify-b-">specify &quot;b&quot;</h1>
<p>fillThree = fillTwo(3)</p>
<h1 id="specify-c-">specify &quot;c&quot;</h1>
<p>answer    = fillThree(5)</p>
<h1 id="specify-d-">specify &quot;d&quot;</h1>
<p>answer
657</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is possible to further illustrate the parallel with closures by presenting the same simple tax-calculation program used in Part 2 (this time using curry()):
Listing 10: Python curried tax calculations</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-keyword">from</span> functional <span class="hljs-keyword">import</span> *
taxcalc = <span class="hljs-keyword">lambda</span> income,rate,deduct: (income-(deduct))*rate

taxCurry = curry(taxcalc)
taxCurry = taxCurry(<span class="hljs-number">50000</span>)
taxCurry = taxCurry(<span class="hljs-number">0.30</span>)
taxCurry = taxCurry(<span class="hljs-number">10000</span>)
<span class="hljs-keyword">print</span> <span class="hljs-string">"Curried taxes due ="</span>,taxCurry

<span class="hljs-keyword">print</span> <span class="hljs-string">"Curried expression taxes due ="</span>, \
      curry(taxcalc)(<span class="hljs-number">50000</span>)(<span class="hljs-number">0.30</span>)(<span class="hljs-number">10000</span>)</code></pre>
<p>Unlike with closures, we need to curry the arguments in a specific order (left to right). But note that functional also contains an rcurry() class that will start at the other end (right to left).
The second print statement in the example at one level is a trivial spelling change from simply calling the normal taxcalc(50000,0.30,10000). In a different level, however, it makes rather clear the concept that every function can be a function of just one argument -- a rather surprising idea to those new to it.</p>
<h1 id="miscellaneous-higher-order-functions">Miscellaneous higher-order functions</h1>
<p>Beyond the &quot;fundamental&quot; operation of currying, functional provides a grab-bag of interesting higher-order functions. Moreover, it is really not hard to write your own higher-order functions -- either with or without functional. The ones in functional provide some interesting ideas, at the least.
For the most part, higher-order functions feel like &quot;enhanced&quot; versions of the standard map(), filter(), and reduce(). Often, the pattern in these functions is roughly &quot;take a function or functions and some lists as arguments, then apply the function(s) to list arguments.&quot; There are a surprising number of interesting and useful ways to play on this theme. Another pattern is &quot;take a collection of functions and create a function that combines their functionality.&quot; Again, numerous variations are possible. Let&#39;s look at some of what functional provides.
The functions sequential() and also() both create a function based on a sequence of component functions. The component functions can then be called with the same argument(s). The main difference between the two is simply that sequential() expects a single list as an argument, while also() takes a list of arguments. In most cases, these are useful for function side effects, but sequential() optionally lets you choose which function provides the combined return value:
Listing 11: Sequential calls to functions (with same args)</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-params">(x)</span>:</span>
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">print</span> x,
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"a"</span>
...
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-params">(x)</span>:</span>
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">print</span> x*<span class="hljs-number">2</span>,
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"b"</span>
...
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-params">(x)</span>:</span>
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">print</span> x*<span class="hljs-number">3</span>,
<span class="hljs-prompt">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"c"</span>
...
<span class="hljs-prompt">&gt;&gt;&gt; </span>r = also(a,b,c)
<span class="hljs-prompt">&gt;&gt;&gt; </span>r
&lt;functional.sequential instance at <span class="hljs-number">0xb86ac</span>&gt;
<span class="hljs-prompt">&gt;&gt;&gt; </span>r(<span class="hljs-number">5</span>)
<span class="hljs-number">5</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span>
<span class="hljs-string">'a'</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>sequential([a,b,c],main=c)(<span class="hljs-string">'x'</span>)
x xx xxx
<span class="hljs-string">'c'</span></code></pre>
<p>The functions disjoin() and conjoin() are similar to sequential() and also() in terms of creating new functions that apply argument(s) to several component functions. But disjoin() asks whether any component functions return true (given the argument(s)), and conjoin() asks whether all components return true. Logical shortcutting is applied, where possible, so some side effects might not occur with disjoin(). joinfuncs() is similar to also(), but returns a tuple of the components&#39; return values rather than selecting a main one.
Where the previous functions let you call multiple functions with the same argument(s), any(), all(), and none_of() let you call the same function against a list of arguments. In general structure, these are a bit like the built-in map(), reduce(), filter() functions. But these particular higher-order functions from functional ask Boolean questions about collections of return values. For example:
Listing 12: Ask about collections of return values</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functional <span class="hljs-keyword">import</span> *
<span class="hljs-prompt">&gt;&gt;&gt; </span>isEven = <span class="hljs-keyword">lambda</span> n: (n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
<span class="hljs-prompt">&gt;&gt;&gt; </span>any([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>], isEven)
<span class="hljs-number">1</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>any([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>], isEven)
<span class="hljs-number">0</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>none_of([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>], isEven)
<span class="hljs-number">1</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>all([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>], isEven)
<span class="hljs-number">1</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>all([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], isEven)
<span class="hljs-number">0</span></code></pre>
<p>A particularly interesting higher-order function for those with a little bit of mathematics background is compose(). The composition of several functions is a &quot;chaining together&quot; of the return value of one function to the input of the next function. The programmer who composes several functions is responsible for making sure the outputs and inputs match up -- but then, that is true any time a programmer uses a return value. A simple example makes it clear:
Listing 13: Creating compositional functions</p>
<pre class="highlight"><code class="hljs python"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minus7</span><span class="hljs-params">(n)</span>:</span> <span class="hljs-keyword">return</span> n-<span class="hljs-number">7</span>
...
<span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">times3</span><span class="hljs-params">(n)</span>:</span> <span class="hljs-keyword">return</span> n*<span class="hljs-number">3</span>
...
<span class="hljs-prompt">&gt;&gt;&gt; </span>minus7(<span class="hljs-number">10</span>)
<span class="hljs-number">3</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>minustimes = compose(times3,minus7)
<span class="hljs-prompt">&gt;&gt;&gt; </span>minustimes(<span class="hljs-number">10</span>)
<span class="hljs-number">9</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>times3(minus7(<span class="hljs-number">10</span>))
<span class="hljs-number">9</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>timesminus = compose(minus7,times3)
<span class="hljs-prompt">&gt;&gt;&gt; </span>timesminus(<span class="hljs-number">10</span>)
<span class="hljs-number">23</span>
<span class="hljs-prompt">&gt;&gt;&gt; </span>minus7(times3(<span class="hljs-number">10</span>))
<span class="hljs-number">23</span></code></pre>
]]></description>
            <link>http://website.com/posts/2014/02/10/Functional_Programming_in_Python_part3</link>
            <guid isPermaLink="true">http://website.com/posts/2014/02/10/Functional_Programming_in_Python_part3</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Sun, 09 Feb 2014 15:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[새해 소망]]></title>
            <description><![CDATA[<ol>
<li><p>무엇이든 방긋 웃으며 ‘예’하는 사람이 된다.</p>
</li>
<li><p>사랑받기보다 사랑하는 사람이 된다.</p>
</li>
<li><p>이해받기 보다 이해하는 사람이 된다</p>
</li>
<li><p>도움받기 보다 도움을 주는 사람이 된다</p>
</li>
<li><p>의지하기보다 의지되는 사람이 된다</p>
</li>
<li><p>화내지 않는 사람이 된다</p>
</li>
<li><p>미워하지 않는 사람이 된다</p>
</li>
<li><p>좋은 일은 손해를 보더라도 기꺼이 하는 사람이된다</p>
</li>
<li><p>실패를 곧 성공의 길로 삼는 사람이 된다.</p>
</li>
<li><p>모르면 묻고, 틀리면 고치고 잘못하면 뉘우치는 사람이 된다.</p>
</li>
</ol>
]]></description>
            <link>http://website.com/posts/2014/01/01/new_year_resolution</link>
            <guid isPermaLink="true">http://website.com/posts/2014/01/01/new_year_resolution</guid>
            <dc:creator><![CDATA[Young Gyu Park]]></dc:creator>
            <pubDate>Tue, 31 Dec 2013 15:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>